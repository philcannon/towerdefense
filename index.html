<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Tower Defense Game</title>
  <style>
    body { margin: 0; font-family: sans-serif; background: #111; color: #fff; }
    canvas { background: #222; display: block; margin: 0 auto; border: 2px solid #333; }
    #ui { text-align: center; margin: 10px; }
    .button { background: #444; color: white; padding: 10px 20px; margin: 5px; cursor: pointer; border: none; }
    .button:hover { background: #666; }
  </style>
</head>
<body>
  <div id="ui">
    <span>Gold: <span id="gold">100</span></span>
    <span style="margin-left:20px;">Health: <span id="health">10</span></span>
    <span style="margin-left:20px;">Score: <span id="score">0</span></span>
    <span style="margin-left:20px;">High Score: <span id="highScore">0</span></span><br>
    <button class="button" onclick="game.startNextWave()">Start Wave</button>
    <button class="button" onclick="game.setTowerType('basic')">Basic Tower (50G)</button>
    <button class="button" onclick="game.setTowerType('sniper')">Sniper Tower (100G)</button>
  </div>

  <canvas id="gameCanvas" width="800" height="600"></canvas>
  <audio id="shootSound" src="https://www.soundjay.com/button/beep-07.wav"></audio>
  <audio id="hitSound" src="https://www.soundjay.com/button/button-3.mp3"></audio>

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    const TILE_SIZE = 40;
    const MAP_WIDTH = canvas.width / TILE_SIZE;
    const MAP_HEIGHT = canvas.height / TILE_SIZE;

    class Game {
      constructor() {
        this.gold = 100;
        this.health = 10;
        this.score = 0;
        this.highScore = parseInt(localStorage.getItem('td_highscore')) || 0;
        this.wave = 0;
        this.selectedTowerType = 'basic';
        this.enemies = [];
        this.towers = [];
        this.projectiles = [];
        this.path = this.generatePath();
        this.map = this.generateMap();
        this.running = true;
        this.selectedTower = null;
        this.initListeners();
        this.updateUI();
        this.loop();
      }

      generatePath() {
        return Array.from({ length: 20 }, (_, i) => ({ x: i, y: 5 }));
      }

      generateMap() {
        const map = [];
        for (let y = 0; y < MAP_HEIGHT; y++) {
          map[y] = [];
          for (let x = 0; x < MAP_WIDTH; x++) {
            map[y][x] = 0;
          }
        }
        for (let p of this.path) map[p.y][p.x] = 1;
        return map;
      }

      setTowerType(type) {
        this.selectedTowerType = type;
      }

      startNextWave() {
        this.wave++;
        const count = 5 + this.wave * 2;
        for (let i = 0; i < count; i++) {
          setTimeout(() => {
            const type = i % 5 === 0 ? 'tank' : (i % 3 === 0 ? 'fast' : 'normal');
            this.enemies.push(new Enemy(this.path, this.wave, type));
          }, i * 800);
        }
      }

      updateUI() {
        document.getElementById('gold').textContent = this.gold;
        document.getElementById('health').textContent = this.health;
        document.getElementById('score').textContent = this.score;
        document.getElementById('highScore').textContent = this.highScore;
      }

      initListeners() {
        canvas.addEventListener('click', (e) => {
          const rect = canvas.getBoundingClientRect();
          const x = Math.floor((e.clientX - rect.left) / TILE_SIZE);
          const y = Math.floor((e.clientY - rect.top) / TILE_SIZE);
          const posX = x * TILE_SIZE;
          const posY = y * TILE_SIZE;

          const existing = this.towers.find(t => t.gridX === x && t.gridY === y);
          if (existing) {
            const upgradeCost = existing.level * 50;
            if (this.gold >= upgradeCost) {
              existing.upgrade();
              this.gold -= upgradeCost;
              this.updateUI();
            }
            return;
          }

          const cost = this.selectedTowerType === 'sniper' ? 100 : 50;
          if (this.map[y][x] === 0 && this.gold >= cost) {
            this.towers.push(new Tower(posX, posY, this.selectedTowerType, x, y));
            this.gold -= cost;
            this.updateUI();
          }
        });
      }

      loop() {
        if (!this.running) return;
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Draw map
        for (let y = 0; y < MAP_HEIGHT; y++) {
          for (let x = 0; x < MAP_WIDTH; x++) {
            ctx.fillStyle = this.map[y][x] === 1 ? '#555' : '#333';
            ctx.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
          }
        }

        for (let tower of this.towers) tower.update(this.enemies, this.projectiles);
        for (let proj of this.projectiles) proj.update();
        this.projectiles = this.projectiles.filter(p => !p.dead);
        this.enemies = this.enemies.filter(e => {
          if (e.health <= 0) {
            this.score += 10;
            this.gold += 10;
            document.getElementById('hitSound').play();
            this.updateUI();
            if (this.score > this.highScore) {
              this.highScore = this.score;
              localStorage.setItem('td_highscore', this.highScore);
            }
            return false;
          }
          if (e.finished) {
            this.health--;
            this.updateUI();
            if (this.health <= 0) {
              alert('Game Over! Refresh to play again.');
              this.running = false;
            }
            return false;
          }
          e.update();
          return true;
        });

        requestAnimationFrame(() => this.loop());
      }
    }

    class Enemy {
      constructor(path, wave, type = 'normal') {
        this.path = path;
        this.index = 0;
        this.x = path[0].x * TILE_SIZE;
        this.y = path[0].y * TILE_SIZE;
        this.type = type;
        const stats = {
          normal: { speed: 1, health: 30 },
          fast: { speed: 2, health: 20 },
          tank: { speed: 0.5, health: 100 }
        }[type];
        this.speed = stats.speed + wave * 0.1;
        this.health = stats.health + wave * 5;
        this.finished = false;
      }

      update() {
        const next = this.path[this.index + 1];
        if (!next) {
          this.finished = true;
          return;
        }
        const tx = next.x * TILE_SIZE;
        const ty = next.y * TILE_SIZE;
        const dx = tx - this.x;
        const dy = ty - this.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < this.speed) this.index++;
        else {
          this.x += this.speed * dx / dist;
          this.y += this.speed * dy / dist;
        }
        ctx.fillStyle = this.type === 'tank' ? '#880' : this.type === 'fast' ? '#0ff' : '#f44';
        ctx.beginPath();
        ctx.arc(this.x + 20, this.y + 20, 15, 0, 2 * Math.PI);
        ctx.fill();
      }
    }

    class Tower {
      constructor(x, y, type, gridX, gridY) {
        this.x = x + TILE_SIZE / 2;
        this.y = y + TILE_SIZE / 2;
        this.gridX = gridX;
        this.gridY = gridY;
        this.type = type;
        this.level = 1;
        this.setStats();
        this.cooldown = 0;
      }

      setStats() {
        const base = {
          basic: { range: 100, rate: 60, damage: 10, color: 'blue' },
          sniper: { range: 200, rate: 100, damage: 25, color: 'cyan' }
        }[this.type];
        this.range = base.range + this.level * 10;
        this.fireRate = base.rate - this.level * 5;
        this.damage = base.damage + this.level * 5;
        this.color = base.color;
      }

      upgrade() {
        this.level++;
        this.setStats();
      }

      update(enemies, projectiles) {
        if (this.cooldown > 0) {
          this.cooldown--;
          return;
        }
        for (let enemy of enemies) {
          const dx = enemy.x - this.x;
          const dy = enemy.y - this.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist < this.range) {
            projectiles.push(new Projectile(this.x, this.y, enemy, this.damage));
            document.getElementById('shootSound').play();
            this.cooldown = this.fireRate;
            break;
          }
        }
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, 10 + this.level, 0, 2 * Math.PI);
        ctx.fill();
      }
    }

    class Projectile {
      constructor(x, y, target, damage) {
        this.x = x;
        this.y = y;
        this.target = target;
        this.damage = damage;
        this.speed = 6;
        this.dead = false;
      }

      update() {
        const dx = this.target.x - this.x;
        const dy = this.target.y - this.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < this.speed) {
          this.target.health -= this.damage;
          this.dead = true;
          return;
        }
        this.x += this.speed * dx / dist;
        this.y += this.speed * dy / dist;
        ctx.fillStyle = 'yellow';
        ctx.beginPath();
        ctx.arc(this.x, this.y, 4, 0, 2 * Math.PI);
        ctx.fill();
      }
    }

    const game = new Game();
  </script>
</body>
</html>
